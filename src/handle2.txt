/*=============================================================================
Leo Tamminen
shophorn @ github
=============================================================================*/
template<typename... Ts>
struct TypeList;

template<typename T, typename... TList>
constexpr u32 indexOf = 0;

template<typename T, typename... TList>
constexpr u32 indexOf<T, TypeList<TList...>> = indexOf<T, TList...>;



template<typename ... Components>
struct ComponentManager;

template<typename... Components>
struct ComponentManager<TypeList<Components...>>
{
	StaticArray<void *, sizeof...(Components)> storage;
};

template<typename T, typename TList>
ArenaArray<T> get_storage_2(ComponentManager<TList> * manager)
{
	return *reinterpret_cast<ArenaArray<T>*>(&manager->storage[indexOf<T, TList>]);
}





using TestComponents = TypeList<int, bool, float>;

global_variable ComponentManager<TestComponents> globalComponentManager;


/* Todo(Leo): this is bad
	1. doesn't work with multiple scenes/allocations
	2. when we reload game, this is lost, and stops working -> prevents hot reloading
*/
template<typename T>
inline global_variable ArenaArray<T>
globalComponentStorage = {};

template<typename T, typename ... Components>
ArenaArray<T> * get_storage(ComponentManager<Components...> * manager)
{
	return &globalComponentStorage<T>;
}

template<typename T>
struct Handle
{
	/* Note(Leo): we will store various metadata in 'reserved_' later, such as
	validity, container index, generation etc. We can manage with u32's max value
	amount of items, and this will still be just a size of pointer. */
	u32 valid_ 		: 1;
	u32 reserved_ 	: 31;
	
	u32 index_;
	

	T * operator->()
	{ 
		DEBUG_ASSERT(thing_ > 0, "Cannot reference uninitialized Handle.");
		return &(*get_storage<T>(&globalComponentManager))[index_];
	}

	operator T * ()
	{
		DEBUG_ASSERT(thing_ > 0, "Cannot reference uninitialized Handle.");
		return &(*get_storage<T>(&globalComponentManager))[index_];	
	}
};

template<typename T>
internal bool32
is_handle_valid(Handle<T> handle)
{
	bool32 result = (handle.thing_ > 0) && (handle.index_ < get_storage<T>(&globalComponentManager)->count());
	return result;	
}

template<typename T>
internal Handle<T>
make_handle(T item)
{
	/* Note(Leo): 	We use concrete item instead of constructor arguments
					and rely on copy elision to remove copy.

					However, I am not sure if it works that way.*/
	Handle<T> result = {};
	result.thing_ = 1;
	result.index_ = push_one(*get_storage<T>(&globalComponentManager), item);
	return result;
}

template<typename T>
internal void
allocate_for_handle(MemoryArena * memoryArena, u32 count)
{
	*get_storage<T>(&globalComponentManager) = reserve_array<T>(memoryArena, count);
}

void ** globalComponentManagers;

template<typename T, typename TList>
T * get_component(ComponentManager<TList> * manager, Handle<T> handle)
{
	return &get_storage_2<T>(&globalComponentManager)[handle.index_];
}

void test()
{
	Handle<void*> h = {0};
	get_component(&globalComponentManager, h);
}